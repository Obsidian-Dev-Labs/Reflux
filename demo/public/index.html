<!DOCTYPE html>
<html>
  <head>
    <title>Dusk</title>
    <style>
      :root {
        --input-height: 48px;
      }

      @font-face {
        font-family: "Inter";
        src: url(./Inter.ttf);
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      html,
      body {
        background-color: #1a1a1a;
        font-family: "Inter";
      }

      .top-bar {
        width: 100%;
        display: flex;
        align-items: center;
        padding: 10px;
        gap: 6px;
      }

      .top-bar div {
        height: var(--input-height);
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        background-color: #ffffff28;
        border: 2px solid #ffffff28;
        border-radius: 10px;
        transition: 150ms ease-in-out;
      }

      .top-bar div.focused {
        border-color: #ffffff80;
      }

      .top-bar div:hover {
        border-color: #ffffff60;
      }

      .top-bar input {
        width: 100%;
        height: 100%;
        background-color: transparent;
        border: none;
        color: #ffffffcd;
        padding-left: 8px;
        font-weight: 600;
        font-size: 18px;
        line-height: 1;
        outline: none;
      }

      .top-bar input::placeholder {
        color: #ffffff80;
        font-weight: 450;
      }

      .top-bar button {
        display: flex;
        align-items: center;
        justify-content: center;
        height: max-content;
        margin-right: 4px;
        padding: 4px;
        background-color: #ffffff28;
        color: #ffffffcd;
        border: 2px solid #ffffff28;
        border-radius: 8px;
        font-weight: 550;
        font-size: 18px;
        cursor: pointer;
      }

      .top-bar button svg {
        width: 24px;
        height: 24px;
        fill: currentColor;
      }

      .iframe-container {
        width: 100%;
        height: calc(100vh - 50px);
        position: relative;
      }

      #frame {
        width: 100%;
        height: 100%;
        border: none;
      }
    </style>
    <script src="/baremux/index.js"></script>
    <script src="/scram/scramjet.controller.js"></script>
  </head>
  <body>
    <div class="top-bar">
      <div>
        <input
          autofocus
          autocapitalize="false"
          id="input"
          type="text"
          placeholder="Enter something..."
        />
        <button>
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M10.5 3.75a6.75 6.75 0 1 0 0 13.5 6.75 6.75 0 0 0 0-13.5ZM2.25 10.5a8.25 8.25 0 1 1 14.59 5.28l4.69 4.69a.75.75 0 1 1-1.06 1.06l-4.69-4.69A8.25 8.25 0 0 1 2.25 10.5Z"
              clip-rule="evenodd"
            />
          </svg>
        </button>
      </div>
    </div>

    <div class="iframe-container">
      <iframe id="frame" src="./home.html"></iframe>
    </div>
  </body>
</html>

<script>
  (async () => {
    function search(input) {
      input = input.trim();
      const searchTemplate = "https://www.duckduckgo.com/?q=%s";
      try {
        return new URL(input).toString();
      } catch (err) {
        try {
          const url = new URL(`http://${input}`);
          if (url.hostname.includes(".")) {
            return url.toString();
          }
          throw new Error("Invalid hostname");
        } catch (err) {
          return searchTemplate.replace("%s", encodeURIComponent(input));
        }
      }
    }

    const scramjet = new ScramjetController({
      prefix: "/scram/route/",
      files: {
        wasm: "/scram/scramjet.wasm.wasm",
        worker: "/scram/scramjet.worker.js",
        client: "/scram/scramjet.client.js",
        shared: "/scram/scramjet.shared.js",
        sync: "/scram/scramjet.sync.js",
      },
      flags: {
        rewriterLogs: true,
      },
    });

    scramjet.init();
    navigator.serviceWorker.register("/sw.js");

    const inputcontainer = document.querySelector(".top-bar div");
    const input = document.getElementById("input");
    const frame = document.getElementById("frame");
    const enter = document.querySelector(".top-bar button");

    enter.addEventListener("click", function () {
      if (input.value) {
        const value = input.value.trim();
        const searchUrl = search(value);
        frame.src = "/ob/route/" + encodeURIComponent(search(searchUrl));
      }
    });

    input.addEventListener("focus", () => {
      inputcontainer.classList.add("focused");
    });

    input.addEventListener("blur", () => {
      inputcontainer.classList.remove("focused");
    });

    input.addEventListener("keypress", function (e) {
      if (e.target.value && e.key == "Enter") {
        e.preventDefault();
        const value = e.target.value.trim();
        const searchUrl = search(value);

        if (value) {
          frame.src = "/scram/route/" + encodeURIComponent(search(searchUrl));
        }
      }
    });

    const control = new MessageChannel();

    const connection = new window.BareMux.BareMuxConnection(
      "/baremux/worker.js"
    );
    await connection.setTransport(
      "/reflux/index.mjs",
      [
        {
          transport: "/epoxy/index.mjs",
          wisp: "wss://gointospace.app/wisp/",
          controlPort: control.port1,
        },
      ],
      [control.port1]
    );

    const client = new window.BareMux.BareClient();
    const response = await client.fetch("https://example.com");
    console.log("Response from example.com:", await response.text());

    window.BMClient = client;
    window.BMConnection = connection;

    function injectDiscordHeadMiddleware() {
      return {
        id: "inject-discord-head",
        onResponse: async ({ request, response }, next) => {
          try {
            // Only proceed if this is a Discord response and it's HTML
            if (
              request.remote.hostname.includes("discord.com") &&
              response.headers["content-type"]?.includes("text/html")
            ) {
              // Get body content as string
              let originalHtml = response.body;

              // If body is not a string (might be a stream or buffer)
              if (typeof originalHtml !== "string") {
                try {
                  // Try to convert body to text
                  originalHtml = await response.body.text();
                } catch (err) {
                  console.error(
                    "[Discord middleware] Failed to read response body:",
                    err
                  );
                  await next();
                  return;
                }
              }

              // Only inject if we have content and it contains a head tag
              if (originalHtml && originalHtml.includes("</head>")) {
                const injectedScript = `
<link rel="stylesheet" href="https://github.com/Vendicated/Vencord/releases/download/devbuild/browser.css">
<script src="https://github.com/Vendicated/Vencord/releases/download/devbuild/browser.js"><\/script>`;

                const modifiedHtml = originalHtml.replace(
                  "</head>",
                  injectedScript + "</head>"
                );

                response.body = modifiedHtml;
                response.headers["content-length"] = String(modifiedHtml.length);

                console.log("[Discord middleware] Successfully injected script");
              } else {
                console.warn(
                  "[Discord middleware] Response doesn't contain </head> tag"
                );
              }
            }
          } catch (error) {
            console.error("[Discord middleware] Error:", error);
          }

          // Always proceed to next middleware
          await next();
        },
      };
    }

    // First, register the fixed middleware
    /*control.port2.postMessage({
      type: "addMiddleware",
      id: "inject-discord-head",
      fn: `(${injectDiscordHeadMiddleware.toString()})()`,
    });*/

    // Then test with these headers
    const headers = {
      "User-Agent":
        "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36",
      "Accept":
        "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8",
      "Accept-Language": "en-US,en;q=0.9",
    };

    // Test the fetch
    /*const discordRes = await window.BMClient.fetch("https://discord.com", {
      headers,
    });
    console.log("Discord response status:", discordRes.status);
    const text = await discordRes.text();
    console.log("Discord response length:", text.length);
    console.log(
      "Discord response:",
      text
    );
    if (text.includes("</head>")) {
      console.log("Discord response contains </head> tag");
    } else {
      console.warn("Discord response does not contain </head> tag");
    }

    if (text.includes("Vendicated/Vencord")) {
      console.log("Vencord script successfully injected");
    } else {
      console.warn("Vencord script not found in response");
    }*/

    function createContentInjectionMiddleware(config = {}) {
      return {
        id: config.id || "content-injection-middleware",
        onResponse: async ({ request, response }, next) => {
          try {
            // Check if we should process this request based on hostname pattern
            const hostnamePattern = config.hostnamePattern || /.*/;
            if (!hostnamePattern.test(request.remote.hostname)) {
              await next();
              return;
            }

            // Check content type - typically we only want to modify HTML
            const contentType = response.headers["content-type"] || "";
            if (!contentType.includes("text/html") && !config.forceProcess) {
              await next();
              return;
            }

            // Get response body as string
            let content = response.body;
            if (typeof content !== "string") {
              try {
                content = await response.body.text();
              } catch (err) {
                console.error("[Injection Middleware] Failed to read response body:", err);
                await next();
                return;
              }
            }

            // Skip if no content
            if (!content) {
              console.warn("[Injection Middleware] Empty response body");
              await next();
              return;
            }

            // Process the content based on injection mode
            let modifiedContent = content;
            
            if (config.injectionMode === "replace" && config.targetPattern) {
              // Replace mode - completely replace matched content
              const pattern = new RegExp(config.targetPattern, config.patternFlags || "g");
              modifiedContent = content.replace(pattern, config.injectionContent);
            } 
            else if (config.injectionMode === "before" && config.targetPattern) {
              // Before mode - insert before matched content
              const pattern = new RegExp(config.targetPattern, config.patternFlags || "");
              modifiedContent = content.replace(pattern, `${config.injectionContent}$&`);
            }
            else if (config.injectionMode === "after" && config.targetPattern) {
              // After mode - insert after matched content
              const pattern = new RegExp(config.targetPattern, config.patternFlags || "");
              modifiedContent = content.replace(pattern, `$&${config.injectionContent}`);
            }
            else if (config.injectionMode === "custom" && typeof config.customProcessor === "function") {
              // Custom mode - use provided function to transform content
              modifiedContent = config.customProcessor(content, request);
            }
            else {
              // Default - append to end of body if no other mode specified
              modifiedContent = content + config.injectionContent;
            }

            // Update the response
            response.body = modifiedContent;
            response.headers["content-length"] = String(modifiedContent.length);

            console.log(`[${config.id || "Injection Middleware"}] Content injection successful`);
          } catch (error) {
            console.error(`[${config.id || "Injection Middleware"}] Error:`, error);
          }

          // Always proceed to next middleware
          await next();
        }
      };
    }

    // Register Discord Vencord injection middleware
    control.port2.postMessage({
      type: "addMiddleware",
      id: "discord-vencord-injector",
      fn: `(${createContentInjectionMiddleware.toString()})({
        id: "discord-vencord-injector",
        hostnamePattern: /discord\.com/,
        injectionMode: "before", 
        targetPattern: "</head>",
        injectionContent: \`
<link rel="stylesheet" href="https://github.com/Vendicated/Vencord/releases/download/devbuild/browser.css">
<script src="https://github.com/Vendicated/Vencord/releases/download/devbuild/browser.js"><\\/script>
\`
      })`,
    });
  })();
  </script>